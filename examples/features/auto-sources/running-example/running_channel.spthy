theory runningV2
begin


/* 
We formalize the following challenge-response protocol
    1. I -> R: {'req',I, n}pk(R)
    2. I <- R: {'rep',n}pk(I)
*/


builtins: asymmetric-encryption


// Public key infrastructure
rule Register_pk:
  [ Fr(~ltkA) ]
  -->
  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]


rule Reveal_ltk:
  [ !Ltk(A, ltkA) ] --[ RevLtk(A)    ]-> [ Out(ltkA) ]


rule (modulo E) Input:
   [ In( x ) ] --[ Input( x ) ]-> [ Ch( x ) ]


rule (modulo E) Output:
   [ Ch( x ) ] --[ Output( x ) ]-> [ Out( x ) ]



rule Rule_I:
  let m1 = aenc{'req', $I, ~n}pkR
  in
    [ Fr(~n), Fr(~m), !Pk(R, pkR),!Ltk($I, ltkI)]
  --[SecretI($I,R,~n)]->
    [ Ch(<~m,m1>), State_I($I, R, ~n, ~m)]



rule Rule_R:
  let m1 = aenc{'req', I, x}pk(ltkR)
      m2 = aenc{'rep', x, y}ltkR
  in
    [ !Ltk(R, ltkR), Ch(<y,m1>), !Pk(I, pkI)]
  -->
    [ Ch(<y,I,R,m2>), State_R(R, I, x, y)]

rule Rule_I2:
   [ Ch( <~m, $I, R, c> ), State_I($I, R, ~n, ~m) ]
  -->
   [
   Ch( <~m, c> )
   ]


lemma nonce_secrecy:
  "     not(
        Ex A B s #i. SecretI(A, B, s) @ i  & (Ex #j. K(s) @ j)
       & not (Ex #r. RevLtk(A) @ r)
        & not (Ex #r. RevLtk(B) @ r)
       )"

end
